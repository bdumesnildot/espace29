---
import Layout from "@layouts/Layout.astro"
import PageTopLayout from "@layouts/PageTopLayout.astro"
import { getCollection } from "astro:content"
import type { CollectionEntry } from "astro:content"
import { EventCard } from "@tina/components/event/EventCard.tsx"
import client from "@tina/__generated__/client"
import { SeasonTitle } from "@tina/components/season/SeasonTitle"

type SeasonWithTinaProps = CollectionEntry<"season"> & {
  tinaProps: Awaited<ReturnType<typeof client.queries.season>>
}

type EventWithTinaProps = CollectionEntry<"event"> & {
  tinaProps: Awaited<ReturnType<typeof client.queries.event>>
}

const seasonCollection = await getCollection("season")
const seasonCollectionWithTinaProps = (
  await Promise.all(
    seasonCollection.map(async (season) => {
      return {
        ...season,
        tinaProps: await client.queries.season({
          relativePath: season.data.tinaInfo.relativePath,
        }),
      }
    })
  )
).sort(
  (a, b) =>
    new Date(b.data.dateStart).getTime() - new Date(a.data.dateStart).getTime()
) // Most recent season first

const eventCollection = await getCollection("event")
const eventCollectionWithTinaProps = await Promise.all(
  eventCollection.map(async (event) => {
    return {
      ...event,
      tinaProps: await client.queries.event({
        relativePath: event.data.tinaInfo.relativePath,
      }),
    }
  })
)

// Helper function to check if an event belongs to a season
const isEventInSeason = (
  eventDate: string,
  seasonStart: string,
  seasonEnd: string
) => {
  const event = new Date(eventDate)
  const start = new Date(seasonStart)
  const end = new Date(seasonEnd)
  return event >= start && event <= end
}

// Group events by season using the eventSeasons data
const eventsBySeason = seasonCollection
  .sort(
    (a, b) =>
      new Date(b.data.dateStart).getTime() -
      new Date(a.data.dateStart).getTime()
  ) // Most recent season first
  .reduce(
    (acc, season) => {
      const {
        dateStart: seasonStart,
        dateEnd: seasonEnd,
        name: seasonName,
      } = season.data
      const eventsInSeason = eventCollectionWithTinaProps
        .filter(({ data: eventData }) =>
          isEventInSeason(eventData.dateStart, seasonStart, seasonEnd)
        )
        .sort(
          (a, b) =>
            new Date(b.data.dateStart).getTime() -
            new Date(a.data.dateStart).getTime()
        ) // Most recent events first within season

      if (eventsInSeason.length > 0) {
        acc[seasonName] = eventsInSeason
      }

      return acc
    },
    {} as Record<string, EventWithTinaProps[]>
  )
---

<Layout title="e29 | Agenda" showBackToTop={true}>
  <main class="flex min-h-full w-full flex-col items-start">
    <PageTopLayout>Agenda</PageTopLayout>

    {
      seasonCollectionWithTinaProps.map(
        ({ data: seasonData, tinaProps: seasonTinaProps }, seasonIndex) => (
          <section class={`w-full`}>
            {
              /* Spacing between seasons */
              seasonIndex > 0 ? <div class="h-16 w-full sm:h-32" /> : null
            }

            {/* Season View (full screen height, fix title and horizontal scroll content) */}
            <div
              id={`season-${seasonIndex}`}
              class="hidden h-screen overflow-hidden sm:flex sm:flex-col"
            >
              <h2 class="font-eina02 mb-1 shrink-0 px-2 py-4 text-5xl text-gray-900 sm:px-10">
                <SeasonTitle {...seasonTinaProps} client:tina />
              </h2>

              <div class="w-full flex-1 overflow-hidden">
                <div
                  id={`events-wrapper-${seasonIndex}`}
                  class="flex h-full flex-row flex-nowrap"
                >
                  <div class="h-full w-10 shrink-0" />
                  {eventsBySeason[seasonData.name].map(
                    ({ data: eventData, tinaProps: eventTinaProps }) => (
                      <div class="h-full min-w-full shrink-0 sm:w-[500px] sm:min-w-[500px]">
                        <EventCard
                          grayscale="untilHover"
                          className="h-full"
                          href={`/agenda/${eventData.tinaInfo.filename}`}
                          {...eventTinaProps}
                          client:tina
                        />
                      </div>
                    )
                  )}
                  <div class="h-full w-10 shrink-0" />
                </div>
              </div>
            </div>

            {/* Mobile Vertical Cards Section */}
            <div class="block w-full px-2 pb-8 sm:hidden">
              <h2 class="font-eina02 mb-2 text-3xl font-semibold text-gray-900 sm:mb-8">
                <SeasonTitle {...seasonTinaProps} client:tina />
              </h2>
              <div class="flex flex-col gap-4">
                {eventsBySeason[seasonData.name].map(
                  ({ data: eventData, tinaProps: eventTinaProps }) => (
                    <div class="h-[650px] w-full">
                      <EventCard
                        grayscale="untilHover"
                        className="h-full"
                        href={`/agenda/${eventData.tinaInfo.filename}`}
                        {...eventTinaProps}
                        client:tina
                      />
                    </div>
                  )
                )}
              </div>
            </div>
          </section>
        )
      )
    }

    <!-- Vertical Content Section After Horizontal Scroll -->
    <section id="vertical-content" class="w-full"></section>
  </main>
</Layout>

<script>
  import { gsap } from "gsap"
  import { ScrollTrigger } from "gsap/ScrollTrigger"

  gsap.registerPlugin(ScrollTrigger)

  function initializeHoverDetection() {
    if (window.innerWidth < 640) return

    const seasonSections = document.querySelectorAll('[id^="season-"]')

    seasonSections.forEach((seasonSection, index) => {
      const cards = seasonSection.querySelectorAll('a[class*="grayscale"]')

      cards.forEach((card) => {
        let isHovered = false

        const handleMouseMove = (e: Event) => {
          const mouseEvent = e as MouseEvent
          const rect = card.getBoundingClientRect()
          const isInBounds =
            mouseEvent.clientX >= rect.left &&
            mouseEvent.clientX <= rect.right &&
            mouseEvent.clientY >= rect.top &&
            mouseEvent.clientY <= rect.bottom

          if (isInBounds && !isHovered) {
            isHovered = true
            card.classList.remove("grayscale")
          } else if (!isInBounds && isHovered) {
            isHovered = false
            card.classList.add("grayscale")
          }
        }

        seasonSection.addEventListener("mousemove", handleMouseMove)
        seasonSection.addEventListener("mouseleave", () => {
          if (isHovered) {
            isHovered = false
            card.classList.add("grayscale")
          }
        })
      })
    })
  }

  function initializeScrollAnimations() {
    if (window.innerWidth < 640) {
      return
    }

    const seasonSections = document.querySelectorAll('[id^="season-"]')

    seasonSections.forEach((seasonSection, index) => {
      const cardsWrapper = document.getElementById(`events-wrapper-${index}`)

      if (!seasonSection || !cardsWrapper) return

      const viewportWidth = window.innerWidth
      const scrollDistance = cardsWrapper.scrollWidth - viewportWidth

      if (scrollDistance <= 0) return

      const deadZone = viewportWidth * 0.1
      const totalScrollDistance = scrollDistance + deadZone * 2

      const tl = gsap.timeline()

      tl.to(cardsWrapper, {
        duration: deadZone,
        ease: "none",
      })

      tl.to(cardsWrapper, {
        x: -scrollDistance,
        duration: scrollDistance,
        ease: "none",
      })

      tl.to(cardsWrapper, {
        duration: deadZone,
        ease: "none",
      })

      ScrollTrigger.create({
        trigger: seasonSection,
        start: "top top",
        end: () => `+=${totalScrollDistance}`,
        scrub: 1,
        pin: true,
        animation: tl,
        invalidateOnRefresh: true,
        anticipatePin: 1,
      })
    })
  }

  document.addEventListener("DOMContentLoaded", () => {
    initializeScrollAnimations()
    initializeHoverDetection()
  })

  window.addEventListener("resize", () => {
    ScrollTrigger.getAll().forEach((trigger) => trigger.kill())
    ScrollTrigger.refresh()
    initializeScrollAnimations()
    initializeHoverDetection()
  })
</script>
